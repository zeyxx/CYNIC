--- Original: learning-service.js
+++ Modified: learning-service.js with EWC integration

@@ Line 19 (imports)
+'use strict';
 
 import { PHI_INV, PHI_INV_2, globalEventBus, EventType } from '@cynic/core';
+import { EWCManager } from './ewc-manager.js';

@@ Line 251 (constructor, after TD tracking initialization)
+    this.tdAlertCooldownMs = 30 * 60 * 1000; // 30 min
+
+    // LV-5: EWC Manager for preventing catastrophic forgetting
+    this.ewcManager = options.ewcManager || new EWCManager({
+      lambda: options.ewcLambda || 0.1,
+    });
+    this.episodesSinceConsolidation = 0;
+
     // Debounced persistence (5s debounce)

@@ Line 449 (_updateQValues method - REPLACE ENTIRE METHOD)
-  _updateQValues(episode, reward) {
-    for (let i = 0; i < episode.actions.length; i++) {
-      const action = episode.actions[i].action;
-      const isLast = i === episode.actions.length - 1;
-
-      const currentQ = this.qTable.get(episode.features, action);
-
-      // For last action, no future state
-      const futureQ = isLast ? 0 :
-        Math.max(...this._getAllActions().map(a =>
-          this.qTable.get(episode.features, a)
-        ));
-
-      // Q(s,a) += α * (r + γ * max(Q(s',a')) - Q(s,a))
-      const target = reward + this.config.discountFactor * futureQ;
-      const newQ = currentQ + this.config.learningRate * (target - currentQ);
-
-      this.qTable.set(episode.features, action, newQ);
-      this.stats.updates++;

+  _updateQValues(episode, reward) {
+    const stateKey = QTable.stateKey(episode.features);
+
+    for (let i = 0; i < episode.actions.length; i++) {
+      const action = episode.actions[i].action;
+      const isLast = i === episode.actions.length - 1;
+
+      const currentQ = this.qTable.get(episode.features, action);
+
+      // For last action, no future state
+      const futureQ = isLast ? 0 :
+        Math.max(...this._getAllActions().map(a =>
+          this.qTable.get(episode.features, a)
+        ));
+
+      // Standard Q-learning target
+      const target = reward + this.config.discountFactor * futureQ;
+      const tdError = target - currentQ;
+      
+      // LV-5: Calculate EWC penalty BEFORE applying update
+      const ewcPenalty = this.ewcManager.calculateEWCPenalty(stateKey, action, currentQ);
+      
+      // Q(s,a) <- Q(s,a) + alpha * [TD-target] - EWC-penalty
+      const standardUpdate = this.config.learningRate * tdError;
+      const newQ = currentQ + standardUpdate - ewcPenalty;
+
+      this.qTable.set(episode.features, action, newQ);
+      this.stats.updates++;
+
+      // LV-5: Record TD-error for Fisher Information computation
+      this.ewcManager.recordUpdate(stateKey, action, Math.abs(tdError));

       // A2: Hot-swap routing weights — emit event for live router update
       try {
-        // LV-1: Track TD-Error for convergence/drift detection
-        const tdError = Math.abs(target - currentQ);
-      this._trackTDError(tdError, {
+      this._trackTDError(Math.abs(tdError), {
           state: episode.features,
           action,
           currentQ,
           target,
           newQ,
           reward,
+          ewcPenalty,
         });
         globalEventBus.publish(EventType.QLEARNING_WEIGHT_UPDATE, {
           state: episode.features,
           action,
           qValue: newQ,
           delta: newQ - currentQ,
+          ewcPenalty,
           serviceId: this.serviceId,
         }, { source: 'learning-service' });

@@ Add new method after endEpisode
+  /**
+   * Consolidate Q-learning knowledge (LV-5: EWC)
+   * Creates snapshot of Q-table + computes Fisher Information
+   */
+  async consolidateKnowledge(taskId = null) {
+    const event = this.ewcManager.consolidate(this.qTable, taskId);
+    
+    try {
+      globalEventBus.publish(EventType.QLEARNING_CONSOLIDATED, {
+        serviceId: this.serviceId,
+        consolidationId: event.consolidationId,
+        fisherStats: event.fisherStats,
+        taskId: event.taskId,
+      }, { source: 'learning-service' });
+    } catch (err) {
+      // Non-blocking
+    }
+
+    await this._doPersist();
+    
+    return event;
+  }

@@ Modify endEpisode (add auto-consolidation)
     this.stats.episodes++;
+    this.episodesSinceConsolidation++;
+
+    // LV-5: Auto-consolidate after N episodes
+    if (this.ewcManager.shouldConsolidate(this.episodesSinceConsolidation)) {
+      await this.consolidateKnowledge();
+      this.episodesSinceConsolidation = 0;
+    }
 
     this.currentEpisode = null;

@@ Modify getStats (add EWC status)
     return {
       ...this.stats,
       accuracy: Math.round(accuracy * 100),
       explorationRate: Math.round(this.explorationRate * 100),
       qTableStats: this.qTable.stats,
       episodesInMemory: this.episodeHistory.length,
+      ewc: this.ewcManager.getStatus(),
+      episodesSinceConsolidation: this.episodesSinceConsolidation,
     };
